<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3U8 æ’­æ”¾å™¨ (å¼ºåŠ›å»å¹¿å‘Šç‰ˆ + æŠ•å±)</title>
    <style>
        /* åŸºç¡€æ ·å¼å’Œå¸ƒå±€ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a; /* æ·±è‰²æ¨¡å¼èƒŒæ™¯ */
            color: #e0e0e0;
        }

        #app-container {
            max-width: 1000px;
            margin: 40px auto;
            padding: 20px;
            background-color: #2d2d2d;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid #3d3d3d;
        }

        h1 {
            color: #4ade80; /* ç»¿è‰²ä¸»é¢˜ */
            text-align: center;
            margin-bottom: 10px;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        #control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            align-items: center;
        }

        #m3u8-input {
            flex-grow: 1;
            padding: 12px 15px;
            border: 1px solid #444;
            background-color: #1a1a1a;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }
        #m3u8-input:focus {
            outline: none;
            border-color: #4ade80;
        }

        #load-button {
            padding: 12px 25px;
            background-color: #4ade80; 
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: filter 0.3s;
        }
        #load-button:hover { filter: brightness(1.1); }

        #cast-button {
            padding: 12px 20px;
            background-color: #3b82f6; /* è“è‰²æŠ•å±æŒ‰é’® */
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: filter 0.3s;
            display: none; /* é»˜è®¤éšè—ï¼Œæ£€æµ‹åˆ°æ”¯æŒæ—¶æ˜¾ç¤º */
            align-items: center;
            gap: 8px;
        }
        #cast-button:hover { filter: brightness(1.1); }

        /* æ’­æ”¾å™¨åŒºåŸŸ */
        #video-container {
            width: 100%;
            aspect-ratio: 16 / 9; 
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid #333;
        }

        #video {
            width: 100%;
            height: 100%;
        }
        
        /* çŠ¶æ€æç¤º */
        #status-message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            background-color: #2a3f4d;
            color: #7dd3fc;
            font-size: 14px;
            line-height: 1.5;
            display: none;
            white-space: pre-line; /* æ”¯æŒæ¢è¡Œ */
        }

        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4ade80;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            z-index: 10;
            font-family: monospace;
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 600px) {
            #control-panel { flex-direction: column; gap: 10px; }
            #m3u8-input, #load-button, #cast-button { width: 100%; box-sizing: border-box; }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "hls.js": "https://aistudiocdn.com/hls.js@^1.6.15",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
<!-- Google Cast åˆå§‹åŒ–å›è°ƒ (å¿…é¡»åœ¨ SDK ä¹‹å‰) -->
<script>
    window['__onGCastApiAvailable'] = function(isAvailable) {
        if (isAvailable) {
            try {
                // åˆå§‹åŒ– Context
                cast.framework.CastContext.getInstance().setOptions({
                    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });
                console.log('Google Cast SDK Initialized via callback');
                
                // æ ‡è®°å…¨å±€çŠ¶æ€
                window.isGCastInitialized = true;
                
                // æ´¾å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œé€šçŸ¥åº”ç”¨å±‚
                document.dispatchEvent(new Event('google-cast-ready'));
            } catch (e) {
                console.error('GCast Init Error:', e);
            }
        }
    };
</script>
<!-- Google Cast SDK -->
<script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
</head>
<body>

<div id="app-container">
    
    <h1>M3U8 æ’­æ”¾å™¨ (å¼ºåŠ›å‡€åŒ–ç‰ˆ)</h1>
    <p style="text-align: center; color: #888; font-size: 0.9rem;">
        æ™ºèƒ½ç§»é™¤å¹¿å‘Šåˆ†ç‰‡ | è·¯å¾„ä¸€è‡´æ€§æ£€æµ‹ | æé™ç¼“å­˜ä¼˜åŒ– | æ”¯æŒæŠ•å±
    </p>

    <div id="control-panel">
        <input 
            type="url" 
            id="m3u8-input" 
            placeholder="åœ¨æ­¤ç²˜è´´ M3U8 åœ°å€ï¼Œæˆ–ä½¿ç”¨ ?url= å‚æ•°"
            value="YOUR_M3U8_URL_HERE"
        >
        <button id="load-button">
            âš¡ï¸ å‡€åŒ–å¹¶æ’­æ”¾
        </button>
        <button id="cast-button">
            ğŸ“º æŠ•å±
        </button>
    </div>
    
    <div id="status-message"></div>

    <div id="video-container">
        <!-- x-webkit-airplay="allow" ç”¨äº iOS AirPlay æ”¯æŒ -->
        <video id="video" controls playsinline x-webkit-airplay="allow"></video>
        <div id="debug-info"></div> 
    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const video = document.getElementById('video');
        const input = document.getElementById('m3u8-input');
        const button = document.getElementById('load-button');
        const castButton = document.getElementById('cast-button');
        const statusDiv = document.getElementById('status-message');
        const debugDiv = document.getElementById('debug-info');
        
        input.value = input.value === 'YOUR_M3U8_URL_HERE' ? '' : input.value;

        // --- æŠ•å±åŠŸèƒ½é›†æˆ ---
        let castType = null; // 'airplay' | 'googlecast'

        // æ˜¾ç¤ºæŠ•å±æŒ‰é’®çš„è¾…åŠ©å‡½æ•°
        function enableCastButton(type) {
            // é¿å…é‡å¤è®¾ç½®
            if (castButton.style.display !== 'none' && castType === type) return;

            castButton.style.display = 'inline-flex';
            castType = type;
            console.log(`Cast enabled: ${type}`);
            
            // å¦‚æœæ˜¯ Google Castï¼Œæ›´æ–°æ–‡æœ¬æç¤ºç”¨æˆ·å¯èƒ½éœ€è¦ç‚¹å‡»æœç´¢
            if (type === 'googlecast') {
                // å¯é€‰ï¼šåœ¨è¿™é‡Œæ”¹å˜æŒ‰é’®æ ·å¼ä»¥æç¤ºç”¨æˆ·
            }
        }

        // 1. æ£€æµ‹ AirPlay (iOS/Safari)
        if (window.WebKitPlaybackTargetAvailabilityEvent) {
            video.addEventListener('webkitplaybacktargetavailabilitychanged', function(event) {
                if (event.availability === 'available') {
                    enableCastButton('airplay');
                }
            });
        }

        // 2. æ£€æµ‹ Google Cast (Android/Chrome)
        // å®šä¹‰åˆå§‹åŒ–é€»è¾‘
        function initGoogleCastUI() {
            if (!window.cast || !window.cast.framework) return;
            
            try {
                const context = cast.framework.CastContext.getInstance();
                
                // ç›‘å¬æŠ•å±çŠ¶æ€å˜åŒ–
                context.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    function(event) {
                        if (event.castState !== cast.framework.CastState.NO_DEVICES_AVAILABLE) {
                            enableCastButton('googlecast');
                        }
                    }
                );
                
                // åªè¦ SDK åŠ è½½æˆåŠŸï¼Œå°±å°è¯•æ˜¾ç¤ºæŒ‰é’®
                // å³ä½¿å½“å‰ NO_DEVICES_AVAILABLEï¼Œç”¨æˆ·ç‚¹å‡»æ—¶ Chrome ä¹Ÿä¼šå°è¯•æœç´¢
                enableCastButton('googlecast');

            } catch (e) {
                console.error('Cast UI Setup Error:', e);
            }
        }

        // ç›‘å¬æ¥è‡ª Head çš„äº‹ä»¶
        document.addEventListener('google-cast-ready', initGoogleCastUI);

        // åŒé‡ä¿é™©ï¼šè½®è¯¢æ£€æŸ¥ SDK æ˜¯å¦åŠ è½½ (è§£å†³äº‹ä»¶ä¸¢å¤±æˆ–æ—¶åºé—®é¢˜)
        if (window.isGCastInitialized) {
            initGoogleCastUI();
        } else {
            let checkCount = 0;
            const castTimer = setInterval(() => {
                checkCount++;
                if (window.isGCastInitialized || (window.cast && window.cast.framework)) {
                    clearInterval(castTimer);
                    initGoogleCastUI();
                }
                // 10ç§’ååœæ­¢æ£€æŸ¥
                if (checkCount > 50) clearInterval(castTimer);
            }, 200);
        }

        // æŠ•å±æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        castButton.addEventListener('click', () => {
            if (castType === 'airplay') {
                if (video.webkitShowPlaybackTargetPicker) {
                    video.webkitShowPlaybackTargetPicker();
                } else {
                    showStatus('AirPlay æš‚ä¸å¯ç”¨', 'error');
                }
            } else if (castType === 'googlecast') {
                const castContext = cast.framework.CastContext.getInstance();
                const session = castContext.getCurrentSession();
                
                if (!session) {
                    // è¯·æ±‚å¼€å§‹æŠ•å±ä¼šè¯
                    castContext.requestSession().then(startCastSession).catch(err => {
                        console.error('Cast Error:', err);
                        if (err !== 'cancel') {
                             showStatus('æŠ•å±è¿æ¥å¤±è´¥: ' + err, 'error');
                        }
                    });
                } else {
                    // å·²ç»è¿æ¥ï¼Œæ‰“å¼€æ§åˆ¶èœå•æˆ–æ–­å¼€
                    // castContext.endCurrentSession(true);
                    // æ‰“å¼€åŸç”Ÿçš„ Cast å¯¹è¯æ¡†
                    castContext.requestSession(); 
                }
            }
        });

        function startCastSession(session) {
            const mediaUrl = input.value.trim(); // æŠ•å±å¿…é¡»ä½¿ç”¨åŸå§‹ URL
            if (!mediaUrl) {
                showStatus('æ— æ³•æŠ•å±ï¼šæ²¡æœ‰æœ‰æ•ˆçš„è§†é¢‘åœ°å€', 'error');
                return;
            }

            const mediaInfo = new chrome.cast.media.MediaInfo(mediaUrl, 'application/x-mpegurl');
            mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
            mediaInfo.metadata.title = 'M3U8 Stream';
            mediaInfo.metadata.subtitle = mediaUrl;

            const request = new chrome.cast.media.LoadRequest(mediaInfo);
            
            session.loadMedia(request).then(
                function() { console.log('Cast load success'); showStatus('æ­£åœ¨æŠ•å±åˆ°è®¾å¤‡...', 'success'); },
                function(errorCode) { console.error('Cast load error', errorCode); showStatus('æŠ•å±åŠ è½½å¤±è´¥ code:' + errorCode, 'error'); }
            );
        }

        // --- UI å·¥å…· ---
        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'error') {
                statusDiv.style.backgroundColor = 'rgba(220, 38, 38, 0.2)';
                statusDiv.style.color = '#fca5a5';
            } else if (type === 'success') {
                statusDiv.style.backgroundColor = 'rgba(22, 163, 74, 0.2)';
                statusDiv.style.color = '#86efac';
            } else {
                statusDiv.style.backgroundColor = '#2a3f4d';
                statusDiv.style.color = '#7dd3fc';
            }
        }
        
        function clearStatus() {
            statusDiv.style.display = 'none';
        }

        function updateDebugInfo(hls) {
            if (!hls || !hls.currentLevel || !hls.levels[hls.currentLevel]) return;
            // è®¡ç®—ç¼“å†²
            const buffer = video.buffered.length > 0 ? (video.buffered.end(video.buffered.length - 1) - video.currentTime).toFixed(1) : '0.0';
            const currentLevel = hls.levels[hls.currentLevel];
            const bitrate = currentLevel.bitrate ? (currentLevel.bitrate / 1000).toFixed(0) : 'Auto';
            debugDiv.textContent = `Buf: ${buffer}s | ${bitrate} kbps | ${currentLevel.width || '?'}x${currentLevel.height || '?'}`;
        }

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // --- æ ¸å¿ƒï¼šM3U8 å¼ºåŠ›æ¸…æ´—é€»è¾‘ ---
        
        // å°†ä»»ä½•è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„ (ç”¨äºåˆ†æå¯¹æ¯”)
        function toAbsolute(url, base) {
            try {
                return new URL(url, base).href;
            } catch (e) {
                return url;
            }
        }

        /**
         * æå–è·¯å¾„ç‰¹å¾æŒ‡çº¹
         * æŒ‡çº¹æ ¼å¼: "Hostname | DirectoryPath | Extension"
         * è¿™æ ·å³ä½¿å¹¿å‘Šæ˜¯ .tsï¼Œåªè¦å®ƒåœ¨ä¸åŒçš„æ–‡ä»¶å¤¹ä¸‹ï¼Œä¹Ÿä¼šè¢«è¯†åˆ«å‡ºæ¥ã€‚
         */
        function getSegmentFingerprint(absUrl) {
            try {
                const u = new URL(absUrl);
                const pathParts = u.pathname.split('/');
                pathParts.pop(); // ç§»é™¤æ–‡ä»¶åï¼Œåªä¿ç•™ç›®å½•è·¯å¾„
                const directory = pathParts.join('/');
                
                // è·å–åç¼€ (å¤„ç† query å‚æ•°)
                const cleanPath = u.pathname;
                const parts = cleanPath.split('.');
                const ext = parts.length > 1 ? parts.pop().toLowerCase() : 'unknown';

                // æŒ‡çº¹: ä¸»æœº + ç›®å½• + åç¼€
                return `${u.hostname}|${directory}|${ext}`;
            } catch (e) {
                return 'invalid|url';
            }
        }

        async function fetchAndCleanM3u8(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const originalContent = await response.text();

            const lines = originalContent.split(/\r?\n/);
            const segments = [];
            const fingerprintCounts = {};

            // 1. ç¬¬ä¸€æ¬¡æ‰«æï¼šæ”¶é›†æ‰€æœ‰åˆ†ç‰‡çš„ç‰¹å¾
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) return;

                // å…³é”®ï¼šå…ˆè½¬ç»å¯¹è·¯å¾„ï¼Œç¡®ä¿ç›¸å¯¹è·¯å¾„ä¹Ÿèƒ½æ­£ç¡®æå–ç›®å½•ç»“æ„
                const absUrl = toAbsolute(trimmed, url);
                const fingerprint = getSegmentFingerprint(absUrl);
                
                if (!fingerprintCounts[fingerprint]) fingerprintCounts[fingerprint] = 0;
                fingerprintCounts[fingerprint]++;

                segments.push({
                    lineIndex: index,
                    fingerprint: fingerprint,
                    absUrl: absUrl
                });
            });

            // 2. æ‰¾å‡ºâ€œç»Ÿæ²»åœ°ä½â€çš„ç‰¹å¾ (æ­£ç‰‡é€šå¸¸å æ¯”æœ€å¤§)
            let dominantFingerprint = '';
            let maxCount = 0;
            const totalSegments = segments.length;

            for (const [fp, count] of Object.entries(fingerprintCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominantFingerprint = fp;
                }
            }
            
            // å®‰å…¨é˜ˆå€¼ï¼šå¦‚æœæœ€ä¸»è¦çš„ç‰¹å¾å æ¯”ä¸åˆ° 50%ï¼Œè¯´æ˜æ–‡ä»¶å¯èƒ½éå¸¸ç¢ç‰‡åŒ–ï¼Œä¸å»ºè®®æ¸…æ´—ï¼Œé˜²æ­¢è¯¯åˆ 
            const dominantRatio = totalSegments > 0 ? (maxCount / totalSegments) : 0;
            const isSafeToClean = dominantRatio > 0.5;

            if (!isSafeToClean) {
                return { 
                    content: originalContent, 
                    removedCount: 0, 
                    totalSegments,
                    log: `æœªè¿›è¡Œæ¸…æ´—ï¼šä¸»ç‰¹å¾å æ¯”è¿‡ä½ (${(dominantRatio*100).toFixed(1)}%)ï¼Œæ— æ³•åŒºåˆ†å¹¿å‘Šä¸æ­£ç‰‡ã€‚`
                };
            }

            // 3. æ ‡è®°éœ€è¦åˆ é™¤çš„è¡Œ
            const linesToRemove = new Set();
            let removedCount = 0;

            segments.forEach(seg => {
                // åªè¦æŒ‡çº¹ä¸åŒ¹é…ï¼Œå°±è§†ä¸ºå¹¿å‘Š/æ‚è´¨
                if (seg.fingerprint !== dominantFingerprint) {
                    linesToRemove.add(seg.lineIndex);
                    removedCount++;

                    // å‘å‰å›æº¯åˆ é™¤ç›¸å…³çš„å…ƒæ•°æ® (EXTINF, EXT-X-BYTERANGE)
                    let j = seg.lineIndex - 1;
                    while (j >= 0) {
                        const prevLine = lines[j].trim();
                        if (prevLine.startsWith('#EXTINF') || prevLine.startsWith('#EXT-X-BYTERANGE')) {
                            linesToRemove.add(j);
                            j--;
                        } else {
                            // é‡åˆ°å…¶ä»–æ ‡ç­¾åœæ­¢ï¼Œé¿å…è¯¯åˆ  #EXT-X-KEY ç­‰å…¨å±€é…ç½®
                            break;
                        }
                    }
                }
            });

            // 4. é‡æ„å†…å®¹ & ä¿®å¤ Key è·¯å¾„
            const newLines = [];
            lines.forEach((line, index) => {
                if (linesToRemove.has(index)) return;
                
                let content = line.trim();
                if (!content) return;

                if (content.startsWith('#')) {
                    // ä¿®å¤åŠ å¯† Key çš„ç›¸å¯¹è·¯å¾„é—®é¢˜
                    // Blob URL æ¨¡å¼ä¸‹ï¼Œç›¸å¯¹è·¯å¾„çš„ Key ä¼šåŠ è½½å¤±è´¥ï¼Œå¿…é¡»è½¬ä¸ºç»å¯¹è·¯å¾„
                    if (content.startsWith('#EXT-X-KEY') && content.includes('URI="')) {
                        content = content.replace(/URI="([^"]+)"/, (match, p1) => {
                            if (p1.startsWith('http') || p1.startsWith('//')) return match;
                            return `URI="${toAbsolute(p1, url)}"`;
                        });
                    }
                    newLines.push(content);
                } else {
                    // åˆ†ç‰‡é“¾æ¥ï¼šç»Ÿä¸€è½¬ä¸ºç»å¯¹è·¯å¾„ï¼Œç¡®ä¿ Blob ç¯å¢ƒä¸‹èƒ½è®¿é—®
                    newLines.push(toAbsolute(content, url));
                }
            });

            // è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºä¸»è¦ç‰¹å¾æ˜¯ä»€ä¹ˆ
            const cleanLog = `åˆ†æå®Œæ¯•ã€‚\næ€»åˆ†ç‰‡: ${totalSegments}\nä¸»ç‰¹å¾(æ­£ç‰‡): [${dominantFingerprint.split('|')[1]}]\nç§»é™¤å¼‚å¸¸åˆ†ç‰‡: ${removedCount} ä¸ª`;

            return {
                content: newLines.join('\n'),
                removedCount: removedCount,
                totalSegments: segments.length,
                log: cleanLog
            };
        }


        // --- æ’­æ”¾æ§åˆ¶ ---
        
        async function loadM3U8(url) {
            if (!url) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„ M3U8 åœ°å€ï¼', 'error');
                return;
            }
            
            if (window.hlsInstance) {
                window.hlsInstance.destroy();
                window.hlsInstance = null;
            }
            if (window.debugTimer) clearInterval(window.debugTimer);
            
            clearStatus();
            showStatus('æ­£åœ¨ä¸‹è½½å¹¶æ·±åº¦åˆ†ææ’­æ”¾åˆ—è¡¨...', 'info');
            
            let finalSource = url;
            let isCleaned = false;

            try {
                // æ‰§è¡Œæ¸…æ´—
                const result = await fetchAndCleanM3u8(url);
                
                if (result.removedCount > 0) {
                    showStatus(`${result.log}\n\næ­£åœ¨ç”Ÿæˆçº¯å‡€æµ...`, 'success');
                    const blob = new Blob([result.content], { type: 'application/vnd.apple.mpegurl' });
                    finalSource = URL.createObjectURL(blob);
                    isCleaned = true;
                } else {
                    showStatus(`${result.log}\n\næ’­æ”¾åˆ—è¡¨éå¸¸æ•´æ´ï¼Œæ— éœ€å‡€åŒ–ã€‚`, 'info');
                }

            } catch (e) {
                console.warn('åˆ†æå¤±è´¥:', e);
                showStatus(`æ— æ³•è·å–æ–‡ä»¶å†…å®¹ (CORS é™åˆ¶æˆ–ç½‘ç»œé”™è¯¯)ï¼Œå°†å°è¯•ç›´æ¥æ’­æ”¾åŸå§‹é“¾æ¥ã€‚\næ³¨æ„ï¼šæ­¤æ—¶æ— æ³•å»é™¤å¹¿å‘Šåˆ†ç‰‡ã€‚`, 'error');
                finalSource = url;
            }

            initHls(finalSource, isCleaned);
        }

        function initHls(sourceUrl, isCleaned) {
            if (Hls.isSupported()) {
                // é…ç½® HLS æé™ç¼“å­˜ä¸ç½‘ç»œä¼˜åŒ–å‚æ•°
                const hlsConfig = {
                    enableWorker: true,            // å¯ç”¨ Web Worker å¤šçº¿ç¨‹
                    lowLatencyMode: false,         // å…³é—­ä½å»¶è¿Ÿæ¨¡å¼ä»¥æ¢å–ç¨³å®šæ€§ (ç‚¹æ’­åœºæ™¯)
                    
                    // --- ç¼“å†²åŒºé…ç½® (æé™ç¼“å­˜) ---
                    startBufferLength: 10,           // èµ·å§‹ç¼“å†²æ—¶é•¿ (ç§’)
                    maxBufferLength: 60,            // æœ€å¤§ç¼“å†²æ—¶é•¿ (ç§’)
                    maxMaxBufferLength: 120,        // å…è®¸çš„æœ€å¤§æœ€å¤§ç¼“å†²æ—¶é•¿ (ç§’)
                    maxBufferSize: 100 * 1024 * 1024, // æœ€å¤§ç¼“å†²åŒºå†…å­˜å¤§å° (100MB)
                    backBufferLength: 90,           // ä¿ç•™åå‘ç¼“å†²æ—¶é•¿ (ç§’)
                    
                    // --- ç½‘ç»œåŠ è½½ä¸é‡è¯• (å¢å¼ºé²æ£’æ€§) ---
                    fragLoadingTimeOut: 20000,      // åˆ†ç‰‡åŠ è½½è¶…æ—¶æ—¶é—´ 20s
                    fragLoadingMaxRetry: 6,         // åˆ†ç‰‡åŠ è½½å¤±è´¥æœ€å¤§é‡è¯•æ¬¡æ•°
                    levelLoadingTimeOut: 20000,     // æ’­æ”¾åˆ—è¡¨åŠ è½½è¶…æ—¶
                    manifestLoadingTimeOut: 20000,  // ä¸»æ’­æ”¾åˆ—è¡¨åŠ è½½è¶…æ—¶
                    
                    // --- å¹¶è¡Œä¸‹è½½ä¸èµ·æ’­ä¼˜åŒ– ---
                    // æ³¨æ„: HLS.js é»˜è®¤ç­–ç•¥é€šå¸¸æ˜¯ä¸²è¡Œä¸‹è½½ä»¥ä¿è¯é¡ºåºï¼Œä½†å¢å¤§ buffer ä¼šè§¦å‘é¢„åŠ è½½
                    // æŸäº›é…ç½®å¦‚ maxBufferHole å¯ä»¥å¸®åŠ©è·³è¿‡å°é”™è¯¯
                    maxBufferHole: 0.5,             // å…è®¸æœ€å¤§0.5ç§’çš„ç©ºæ´è·³è¿‡
                };

                const hls = new Hls(hlsConfig);
                window.hlsInstance = hls;

                hls.loadSource(sourceUrl);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    video.play().catch(() => showStatus("æ³¨æ„ï¼šæµè§ˆå™¨å·²é˜»æ­¢è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾ã€‚", 'info'));
                    window.debugTimer = setInterval(() => updateDebugInfo(hls), 1000);
                });
                
                hls.on(Hls.Events.ERROR, function (event, data) {
                    if (data.fatal) {
                       switch(data.type) {
                           case Hls.ErrorTypes.NETWORK_ERROR:
                                showStatus("ç½‘ç»œé”™è¯¯ï¼Œå°è¯•é‡æ–°è¿æ¥...", 'error');
                                hls.startLoad();
                                break;
                           case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log("åª’ä½“è§£ç é”™è¯¯ï¼Œå°è¯•æ¢å¤...");
                                hls.recoverMediaError();
                                break;
                           default:
                                showStatus(`æ’­æ”¾å™¨è‡´å‘½é”™è¯¯: ${data.details}`, 'error');
                                hls.destroy();
                                break;
                       }
                    }
                });
                
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari åŸç”Ÿæ”¯æŒ
                video.src = sourceUrl;
                video.addEventListener('loadedmetadata', () => video.play());
            }
        }
        
        // --- åˆå§‹åŒ– ---
        const urlParam = getUrlParameter('url');
        let initialUrl = input.value.trim();

        if (urlParam) {
            initialUrl = urlParam;
            input.value = initialUrl;
        } else {
            initialUrl = initialUrl === 'YOUR_M3U8_URL_HERE' ? '' : initialUrl;
        }

        button.addEventListener('click', () => loadM3U8(input.value.trim()));
        input.addEventListener('keydown', (e) => e.key === 'Enter' && loadM3U8(input.value.trim()));
        
        if (initialUrl) loadM3U8(initialUrl);
        
        window.addEventListener('beforeunload', () => {
            if (window.debugTimer) clearInterval(window.debugTimer);
            if (window.hlsInstance) window.hlsInstance.destroy();
        });
    });
</script>

</body>
</html>
