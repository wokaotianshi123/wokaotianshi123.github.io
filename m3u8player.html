<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3U8 播放器 (强力去广告版)</title>
    <style>
        /* 基础样式和布局 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a; /* 深色模式背景 */
            color: #e0e0e0;
        }

        #app-container {
            max-width: 1000px;
            margin: 40px auto;
            padding: 20px;
            background-color: #2d2d2d;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid #3d3d3d;
        }

        h1 {
            color: #4ade80; /* 绿色主题 */
            text-align: center;
            margin-bottom: 10px;
        }

        /* 控制面板样式 */
        #control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            align-items: center;
        }

        #m3u8-input {
            flex-grow: 1;
            padding: 12px 15px;
            border: 1px solid #444;
            background-color: #1a1a1a;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }
        #m3u8-input:focus {
            outline: none;
            border-color: #4ade80;
        }

        #load-button {
            padding: 12px 25px;
            background-color: #4ade80; 
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: filter 0.3s;
        }
        #load-button:hover { filter: brightness(1.1); }

        /* 播放器区域 */
        #video-container {
            width: 100%;
            aspect-ratio: 16 / 9; 
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid #333;
        }

        #video {
            width: 100%;
            height: 100%;
        }
        
        /* 状态提示 */
        #status-message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            background-color: #2a3f4d;
            color: #7dd3fc;
            font-size: 14px;
            line-height: 1.5;
            display: none;
            white-space: pre-line; /* 支持换行 */
        }

        /* 调试信息 */
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4ade80;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            z-index: 10;
            font-family: monospace;
        }
        
        /* 移动端优化 */
        @media (max-width: 600px) {
            #control-panel { flex-direction: column; gap: 10px; }
            #m3u8-input, #load-button { width: 100%; box-sizing: border-box; }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "hls.js": "https://aistudiocdn.com/hls.js@^1.6.15",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
</head>
<body>

<div id="app-container">
    
    <h1>M3U8 播放器 (强力净化版)</h1>
    <p style="text-align: center; color: #888; font-size: 0.9rem;">
        智能移除广告分片 | 路径一致性检测 | 极限缓存优化
    </p>

    <div id="control-panel">
        <input 
            type="url" 
            id="m3u8-input" 
            placeholder="在此粘贴 M3U8 地址，或使用 ?url= 参数"
            value="YOUR_M3U8_URL_HERE"
        >
        <button id="load-button">
            ⚡️ 净化并播放
        </button>
    </div>
    
    <div id="status-message"></div>

    <div id="video-container">
        <video id="video" controls playsinline></video>
        <div id="debug-info"></div> 
    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const video = document.getElementById('video');
        const input = document.getElementById('m3u8-input');
        const button = document.getElementById('load-button');
        const statusDiv = document.getElementById('status-message');
        const debugDiv = document.getElementById('debug-info');
        
        input.value = input.value === 'YOUR_M3U8_URL_HERE' ? '' : input.value;

        // --- UI 工具 ---
        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'error') {
                statusDiv.style.backgroundColor = 'rgba(220, 38, 38, 0.2)';
                statusDiv.style.color = '#fca5a5';
            } else if (type === 'success') {
                statusDiv.style.backgroundColor = 'rgba(22, 163, 74, 0.2)';
                statusDiv.style.color = '#86efac';
            } else {
                statusDiv.style.backgroundColor = '#2a3f4d';
                statusDiv.style.color = '#7dd3fc';
            }
        }
        
        function clearStatus() {
            statusDiv.style.display = 'none';
        }

        function updateDebugInfo(hls) {
            if (!hls || !hls.currentLevel || !hls.levels[hls.currentLevel]) return;
            // 计算缓冲
            const buffer = video.buffered.length > 0 ? (video.buffered.end(video.buffered.length - 1) - video.currentTime).toFixed(1) : '0.0';
            const currentLevel = hls.levels[hls.currentLevel];
            const bitrate = currentLevel.bitrate ? (currentLevel.bitrate / 1000).toFixed(0) : 'Auto';
            debugDiv.textContent = `Buf: ${buffer}s | ${bitrate} kbps | ${currentLevel.width || '?'}x${currentLevel.height || '?'}`;
        }

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // --- 核心：M3U8 强力清洗逻辑 ---
        
        // 将任何路径转换为绝对路径 (用于分析对比)
        function toAbsolute(url, base) {
            try {
                return new URL(url, base).href;
            } catch (e) {
                return url;
            }
        }

        /**
         * 提取路径特征指纹
         * 指纹格式: "Hostname | DirectoryPath | Extension"
         * 这样即使广告是 .ts，只要它在不同的文件夹下，也会被识别出来。
         */
        function getSegmentFingerprint(absUrl) {
            try {
                const u = new URL(absUrl);
                const pathParts = u.pathname.split('/');
                pathParts.pop(); // 移除文件名，只保留目录路径
                const directory = pathParts.join('/');
                
                // 获取后缀 (处理 query 参数)
                const cleanPath = u.pathname;
                const parts = cleanPath.split('.');
                const ext = parts.length > 1 ? parts.pop().toLowerCase() : 'unknown';

                // 指纹: 主机 + 目录 + 后缀
                return `${u.hostname}|${directory}|${ext}`;
            } catch (e) {
                return 'invalid|url';
            }
        }

        async function fetchAndCleanM3u8(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const originalContent = await response.text();

            const lines = originalContent.split(/\r?\n/);
            const segments = [];
            const fingerprintCounts = {};

            // 1. 第一次扫描：收集所有分片的特征
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) return;

                // 关键：先转绝对路径，确保相对路径也能正确提取目录结构
                const absUrl = toAbsolute(trimmed, url);
                const fingerprint = getSegmentFingerprint(absUrl);
                
                if (!fingerprintCounts[fingerprint]) fingerprintCounts[fingerprint] = 0;
                fingerprintCounts[fingerprint]++;

                segments.push({
                    lineIndex: index,
                    fingerprint: fingerprint,
                    absUrl: absUrl
                });
            });

            // 2. 找出“统治地位”的特征 (正片通常占比最大)
            let dominantFingerprint = '';
            let maxCount = 0;
            const totalSegments = segments.length;

            for (const [fp, count] of Object.entries(fingerprintCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominantFingerprint = fp;
                }
            }
            
            // 安全阈值：如果最主要的特征占比不到 50%，说明文件可能非常碎片化，不建议清洗，防止误删
            const dominantRatio = totalSegments > 0 ? (maxCount / totalSegments) : 0;
            const isSafeToClean = dominantRatio > 0.5;

            if (!isSafeToClean) {
                return { 
                    content: originalContent, 
                    removedCount: 0, 
                    totalSegments,
                    log: `未进行清洗：主特征占比过低 (${(dominantRatio*100).toFixed(1)}%)，无法区分广告与正片。`
                };
            }

            // 3. 标记需要删除的行
            const linesToRemove = new Set();
            let removedCount = 0;

            segments.forEach(seg => {
                // 只要指纹不匹配，就视为广告/杂质
                if (seg.fingerprint !== dominantFingerprint) {
                    linesToRemove.add(seg.lineIndex);
                    removedCount++;

                    // 向前回溯删除相关的元数据 (EXTINF, EXT-X-BYTERANGE)
                    let j = seg.lineIndex - 1;
                    while (j >= 0) {
                        const prevLine = lines[j].trim();
                        if (prevLine.startsWith('#EXTINF') || prevLine.startsWith('#EXT-X-BYTERANGE')) {
                            linesToRemove.add(j);
                            j--;
                        } else {
                            // 遇到其他标签停止，避免误删 #EXT-X-KEY 等全局配置
                            break;
                        }
                    }
                }
            });

            // 4. 重构内容 & 修复 Key 路径
            const newLines = [];
            lines.forEach((line, index) => {
                if (linesToRemove.has(index)) return;
                
                let content = line.trim();
                if (!content) return;

                if (content.startsWith('#')) {
                    // 修复加密 Key 的相对路径问题
                    // Blob URL 模式下，相对路径的 Key 会加载失败，必须转为绝对路径
                    if (content.startsWith('#EXT-X-KEY') && content.includes('URI="')) {
                        content = content.replace(/URI="([^"]+)"/, (match, p1) => {
                            if (p1.startsWith('http') || p1.startsWith('//')) return match;
                            return `URI="${toAbsolute(p1, url)}"`;
                        });
                    }
                    newLines.push(content);
                } else {
                    // 分片链接：统一转为绝对路径，确保 Blob 环境下能访问
                    newLines.push(toAbsolute(content, url));
                }
            });

            // 调试日志：显示主要特征是什么
            const cleanLog = `分析完毕。\n总分片: ${totalSegments}\n主特征(正片): [${dominantFingerprint.split('|')[1]}]\n移除异常分片: ${removedCount} 个`;

            return {
                content: newLines.join('\n'),
                removedCount: removedCount,
                totalSegments: segments.length,
                log: cleanLog
            };
        }


        // --- 播放控制 ---
        
        async function loadM3U8(url) {
            if (!url) {
                showStatus('请输入有效的 M3U8 地址！', 'error');
                return;
            }
            
            if (window.hlsInstance) {
                window.hlsInstance.destroy();
                window.hlsInstance = null;
            }
            if (window.debugTimer) clearInterval(window.debugTimer);
            
            clearStatus();
            showStatus('正在下载并深度分析播放列表...', 'info');
            
            let finalSource = url;
            let isCleaned = false;

            try {
                // 执行清洗
                const result = await fetchAndCleanM3u8(url);
                
                if (result.removedCount > 0) {
                    showStatus(`${result.log}\n\n正在生成纯净流...`, 'success');
                    const blob = new Blob([result.content], { type: 'application/vnd.apple.mpegurl' });
                    finalSource = URL.createObjectURL(blob);
                    isCleaned = true;
                } else {
                    showStatus(`${result.log}\n\n播放列表非常整洁，无需净化。`, 'info');
                }

            } catch (e) {
                console.warn('分析失败:', e);
                showStatus(`无法获取文件内容 (CORS 限制或网络错误)，将尝试直接播放原始链接。\n注意：此时无法去除广告分片。`, 'error');
                finalSource = url;
            }

            initHls(finalSource, isCleaned);
        }

        function initHls(sourceUrl, isCleaned) {
            if (Hls.isSupported()) {
                // 配置 HLS 极限缓存与网络优化参数
                const hlsConfig = {
                    enableWorker: true,            // 启用 Web Worker 多线程
                    lowLatencyMode: false,         // 关闭低延迟模式以换取稳定性 (点播场景)
                    
                    // --- 缓冲区配置 (极限缓存) ---
                    startBufferLength: 10,           // 起始缓冲时长 (秒)
                    maxBufferLength: 60,            // 最大缓冲时长 (秒)
                    maxMaxBufferLength: 120,        // 允许的最大最大缓冲时长 (秒)
                    maxBufferSize: 100 * 1024 * 1024, // 最大缓冲区内存大小 (100MB)
                    backBufferLength: 90,           // 保留后向缓冲时长 (秒)
                    
                    // --- 网络加载与重试 (增强鲁棒性) ---
                    fragLoadingTimeOut: 20000,      // 分片加载超时时间 20s
                    fragLoadingMaxRetry: 6,         // 分片加载失败最大重试次数
                    levelLoadingTimeOut: 20000,     // 播放列表加载超时
                    manifestLoadingTimeOut: 20000,  // 主播放列表加载超时
                    
                    // --- 并行下载与起播优化 ---
                    // 注意: HLS.js 默认策略通常是串行下载以保证顺序，但增大 buffer 会触发预加载
                    // 某些配置如 maxBufferHole 可以帮助跳过小错误
                    maxBufferHole: 0.5,             // 允许最大0.5秒的空洞跳过
                };

                const hls = new Hls(hlsConfig);
                window.hlsInstance = hls;

                hls.loadSource(sourceUrl);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    video.play().catch(() => showStatus("注意：浏览器已阻止自动播放，请手动点击播放。", 'info'));
                    window.debugTimer = setInterval(() => updateDebugInfo(hls), 1000);
                });
                
                hls.on(Hls.Events.ERROR, function (event, data) {
                    if (data.fatal) {
                       switch(data.type) {
                           case Hls.ErrorTypes.NETWORK_ERROR:
                                showStatus("网络错误，尝试重新连接...", 'error');
                                hls.startLoad();
                                break;
                           case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log("媒体解码错误，尝试恢复...");
                                hls.recoverMediaError();
                                break;
                           default:
                                showStatus(`播放器致命错误: ${data.details}`, 'error');
                                hls.destroy();
                                break;
                       }
                    }
                });
                
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari 原生支持
                video.src = sourceUrl;
                video.addEventListener('loadedmetadata', () => video.play());
            }
        }
        
        // --- 初始化 ---
        const urlParam = getUrlParameter('url');
        let initialUrl = input.value.trim();

        if (urlParam) {
            initialUrl = urlParam;
            input.value = initialUrl;
        } else {
            initialUrl = initialUrl === 'YOUR_M3U8_URL_HERE' ? '' : initialUrl;
        }

        button.addEventListener('click', () => loadM3U8(input.value.trim()));
        input.addEventListener('keydown', (e) => e.key === 'Enter' && loadM3U8(input.value.trim()));
        
        if (initialUrl) loadM3U8(initialUrl);
        
        window.addEventListener('beforeunload', () => {
            if (window.debugTimer) clearInterval(window.debugTimer);
            if (window.hlsInstance) window.hlsInstance.destroy();
        });
    });
</script>

</body>
</html>
